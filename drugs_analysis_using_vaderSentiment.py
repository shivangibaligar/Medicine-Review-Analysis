# -*- coding: utf-8 -*-
"""drugs_analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pRSucZGzPJOHbil9fq1_jT3WCazKPmkY
"""

#from google.colab import drive
#drive.mount('/content/gdrive', force_remount=True)

def tell_medicine() :

  import pandas as pd



  #data = pd.read_table(r"/content/gdrive/My Drive/drugs_reviews_based_research work/drugsComTrain_raw.tsv",sep = "\t")
  data = pd.read_table("drugsComTrain_raw.tsv",sep = "\t")

  #print(type(data))
  #data.head(10)
  #data.loc[0:10,:]
  data = data.iloc[1:500,1:]
  #single column in dataframe is called series
  data['condition'] = data['condition'].str.lower()
  #data.head()

  #print(data.head(10))

  #print("Dimension of the datset is before preprocessing :",data.shape)
  #data.loc[0:5,"drugName"]
  medicines_name = data["drugName"].unique()
  #print("count of unique medicines : ",len(medicines_name))

  conditions_name = data["condition"].unique()
  #print("count of unique conditions : ",len(conditions_name))

  #print("total no. of unique reviews : ",len(data["review"].unique()))

  # Drop rows with any empty cells 
  updated_data1=data.dropna(axis=0, how='any', thresh=None, subset=None, inplace=False)

  #print("Dimension of the datset is after removing empty cell rows :",data.shape)
  #data.loc[0:5,"drugName"]
  medicines_name = updated_data1["drugName"].unique()
  #print("count of unique medicines after removing empty cell rows : ",len(medicines_name))

  conditions_name = updated_data1["condition"].unique()
  #print("count of unique conditions after removing empty cell rows: ",len(conditions_name))
   
  #print("total no. of unique reviews : after removing empty cell rows ",len(updated_data1["review"].unique()))

  #for index,row in updated_data1.iloc[:10,].iterrows() :
    #print(index,row)
  #for index,row in updated_data1.iloc[:10,].iterrows():
    #print(row)
  #for index,row in updated_data1.iloc[:10,].iterrows():
    #print(row["review"])
  #for index,row in updated_data1.iloc[:10,].iterrows():
    #print(row["review"])

  #print(conditions_name)
  condition_with_medicines_dict = dict.fromkeys(conditions_name) #default value is 0

  for condition in conditions_name :
    #print(updated_data1.loc[data['condition'] == condition])
    #return rows
    required_df = updated_data1.loc[updated_data1['condition'] == condition]
    #print(required_df["drugName"].unique())
    un_medi_list = required_df["drugName"].unique()
    #condition_with_medicine_dict holds condition name and all its corresponding medicines
    condition_with_medicines_dict[condition] = list(un_medi_list)

  #updated_data1["review"]
  #condition_with_medicines_dict
  #type(updated_data1["condition"].str)
  #updated_data1.loc[:10,"condition"]
  #updated_data1.loc[:,"condition"].str.contains("users found this comment helpful.")
  unrequired_data = updated_data1.loc[updated_data1["condition"].str.contains("users found this comment helpful.")]
  #print("no of lines which contains this only'users found this comment helpful' inplace of condition names : ",unrequired_data.shape[0])

  # eliminating these 900 rows from our dataset to make more efficient data

  updated_data2 = updated_data1.loc[~updated_data1["condition"].str.contains("users found this comment helpful.")]

  #print("Dimension of the dataset is after removing  'users found this comment helpful.' containing cell rows : ",updated_data2.shape)

  medicines_name = updated_data2["drugName"].unique()
  #print("count of unique medicines after this : ",len(medicines_name))

  conditions_name = updated_data2["condition"].unique()
  #print("count of unique conditions after this :  ",len(conditions_name))
   
  #print("total no. of unique reviews : after this :",len(updated_data2["review"].unique()))

  #print(conditions_name)

  """['Birth Control' 'Opiate Dependence' 'Emergency Contraception'
   'Bipolar Disorde' 'Epilepsy' 'Migraine Prevention' 'Depression'
    'Cough' 'Obesity' 'Urinary Tract Infection'
    'Chronic Myelogenous Leukemia' 'HIV Infection' 'Insomnia'
    'Vaginal Yeast Infection'  'Panic Disorde' 'Migraine' 'Pain' 'Irritable Bowel Syndrome'
    'Constipation'  'Psychosis'
   'Muscle Spasm' 'Hepatitis C'  'Diabetes, Type 2'
   'Asthma, Maintenance' 'Non-Small Cell Lung Cance' 'Schizophrenia'
   'Smoking Cessation' 'Anxiety' 'Acne' 'emale Infertility'
   'Constipation, Acute' 'Constipation, Drug Induced' 'Erectile Dysfunction'
    'Underactive Thyroid' 'Chronic Pain'
   'Skin and Structure Infection' 'Tinnitus'
   'Major Depressive Disorde' 'Anxiety and Stress' 
   'High Blood Pressure' 
   'Bronchitis'
   'Obsessive Compulsive Disorde'
   'Breakthrough Pain'
   'Seizures' 'Neuropathic Pain' 'Sedation' 'Menstrual Disorders'
   'Allergic Rhinitis' 'Anesthesia'
   'Diabetes, Type 1'
   'Abnormal Uterine Bleeding' 'Weight Loss' 'Constipation, Chronic'
   'Breast Cancer, Metastatic' 'Period Pain' 'Kidney Infections' 'Generalized Anxiety Disorde' 'Asthma' 
   'High Cholesterol'  'Hyperthyroidism' 'Back Pain'
    'Asthma, acute'
   'Herpes Simplex, Suppression' 'Bacterial Infection'
   'Diaper Rash' 
  'Dental Abscess' 'Headache' 'Hypersomnia'
   'Breast Cance' 'Sore Throat'
   'Pain/Feve'  'Polycystic Ovary Syndrome'
   'Influenza' 'Hypothyroidism, After Thyroid Removal'
   'Nausea/Vomiting, Postoperative' 'Gastroparesis'
    'Motion Sickness'  'Autism' 'Stomach Ulce' 'Nausea/Vomiting'
   'Paranoid Disorde'
    'mance Anxiety' 'Night Terrors'
   'High Cholesterol, Familial Heterozygous' 
   'Nasal Congestion' 'Conjunctivitis, Bacterial'
   'Post Traumatic Stress Disorde' 'Alcohol Withdrawal' 'Cold Sores' 
   'Anorexia' 'Breast Cancer, Adjuvant' 'Cough and Nasal Congestion'
   'Inflammatory Conditions' 'Bacterial Skin Infection'
   'Cold Symptoms' 'Labor Pain' 'Dry Skin'
  'Pneumonia' 'Malaria Prevention'
    'Allergies'
   'Diarrhea'
   'Seasonal Allergic Conjunctivitis' 'Nausea/Vomiting of Pregnancy' 
   'Cance'
   'Diarrhea, Chronic'
   'Ovarian Cysts' 
   'atigue' 'Social Anxiety Disorde'' 'Eye Redness' 
   'Seizure Prevention' 'Skin Rash'
   'Heart Attack'  'Indigestion'
   'Hepatitis B' 'Burns, External' Allergic Reactions' 'Muscle Pain'  'Malaria'
   'High Cholesterol, Familial Homozygous'
   'Swine Flu'
   "Tourette's Syndrome"
   'Vitamin D Deficiency'
   "Alzheimer's Disease" 'Iron Deficiency Anemia'  'Hiccups'
    'Cyclic Vomiting Syndrome'  'Conjunctivitis'
    'Vitamin/Mineral Supplementation and Deficiency'
   'Vitamin K Deficiency' 
  'Lactose Intolerance' 'B12 Nutritional Deficiency'
   'Oral and Dental Conditions'
    'Sleep Paralysis'
    'Neck Pain'
   'Hepatitis B Prevention' 'Tuberculosis, Active'
  """

  abc=['Birth Control', 'Opiate Dependence', 'Emergency Contraception', 'Bipolar Disorder', 'Epilepsy', 'Migraine Prevention', 'Depression', 'Cough', 'Obesity', 'Urinary Tract Infection', 
       'Chronic Myelogenous Leukemia', 'HIV Infection', 'Insomnia', 'Panic Disorder', 'Migraine', 'Pain', 'Irritable Bowel Syndrome', 'Constipation', 'Psychosis', 'Muscle Spasm', 
       'Hepatitis C', 'Diabetes, Type 2', 'Asthma, Maintenance', 'Non-Small Cell Lung Cancer', 'Schizophrenia', 'Smoking Cessation', 'Anxiety', 'Acne', 'Female Infertility',
       'Constipation, Acute', 'Constipation, Drug Induced', 'Erectile Dysfunction', 'Underactive Thyroid', 'Chronic Pain', 'Skin and Structure Infection', 'Tinnitus', 
       'Major Depressive Disorder', 'Anxiety and Stress', 'High Blood Pressure', 'Bronchitis', 'Obsessive Compulsive Disorde', 'Breakthrough Pain', 'Seizures', 
       'Neuropathic Pain', 'Sedation', 'Menstrual Disorders', 'Allergic Rhinitis', 'Anesthesia', 'Diabetes, Type 1', 'Abnormal Uterine Bleeding', 'Weight Loss', 
       'Constipation, Chronic', 'Breast Cancer, Metastatic', 'Period Pain', 'Kidney Infections', 'Generalized Anxiety Disorde', 'Asthma', 'High Cholesterol', 'Hyperthyroidism',
       'Back Pain', 'Asthma, acute', 'Herpes Simplex, Suppression', 'Bacterial Infection', 'Diaper Rash', 'Dental Abscess', 'Headache', 'Hypersomnia', 'Breast Cancer', 'Sore Throat', 
       'Pain/Fever', 'Polycystic Ovary Syndrome', 'Influenza', 'Hypothyroidism, After Thyroid Removal', 'Nausea/Vomiting, Postoperative', 'Gastroparesis', 'Motion Sickness', 'Autism',
       'Stomach Ulcer', 'Nausea/Vomiting', 'Paranoid Disorde', 'Performance Anxiety', 'Night Terrors', 'High Cholesterol, Familial Heterozygous', 'Nasal Congestion', 'Conjunctivitis, Bacterial', 
       'Post Traumatic Stress Disorde', 'Alcohol Withdrawal', 'Cold Sores', 'Anorexia', 'Breast Cancer, Adjuvant', 'Cough and Nasal Congestion', 'Inflammatory Conditions', 
       'Bacterial Skin Infection', 'Cold Symptoms', 'Labor Pain', 'Dry Skin', 'Pneumonia', 'Malaria Prevention', 'Allergies', 'Diarrhea', 'Seasonal Allergic Conjunctivitis',
       'Nausea/Vomiting of Pregnancy', 'Cancer', 'Diarrhea, Chronic', 'Ovarian Cysts', 'Fatigue', 'Social Anxiety Disorder', 'Eye Redness', 'Seizure Prevention', 'Skin Rash', 
       'Heart Attack', 'Indigestion', 'Hepatitis B', 'Burns, External Allergic Reactions', 'Muscle Pain', 'Malaria', 'High Cholesterol, Familial Homozygous', 'Swine Flu', "Tourette's Syndrome", 
       'Vitamin D Deficiency', "Alzheimer's Disease", 'Iron Deficiency Anemia', 'Hiccups', 'Cyclic Vomiting Syndrome', 'Conjunctivitis', 'Vitamin/Mineral Supplementation and Deficiency', 'Vitamin K Deficiency', 
       'Lactose Intolerance', 'B12 Nutritional Deficiency', 'Oral and Dental Conditions', 'Sleep Paralysis', 'Neck Pain', 'Hepatitis B Prevention', 'Tuberculosis, Active']

  abc = [string.lower() for string in abc] #nesting
  
  #print(len(abc))

  # overwriting values again,after getting updated_data2
  conditions_name = updated_data2["condition"].unique()

  condition_with_medicines_dict = dict.fromkeys(conditions_name)

  for condition in conditions_name :
    required_df = updated_data2.loc[updated_data2['condition'] == condition]
    un_medi_list = required_df["drugName"].unique()
    condition_with_medicines_dict[condition] = list(un_medi_list)

  # condition_with_medicines_dict

  #condition_with_medicines_dict['swine flu']

  reviews = updated_data2["review"]
  #type(reviews)
  """for i in reviews[:10]:
    pass"""
    #print(i)

  """
  import nltk
  nltk.download('stopwords')

  nltk.download('punkt')
  """

  # nltk(natural language tool kit) library
  # we import (include) word_tokenize method
  # from nltk library
  from nltk import word_tokenize
  #from nltk.stem import PorterStemmer
  #from nltk.stem import WordNetLemmatizer

  # we import stopword class from nltk lib
  from nltk.corpus import stopwords


  # create set of english stopwords
  stopwords = set(stopwords.words('english'))

  #print(len(stopwords))
  # these words are very important in sentiment analysis, so we can't take it as a stopwords
  not_stop = {"aren't","couldn't","didn't","doesn't","don't","hadn't","hasn't","haven't",
              "isn't","mightn't","mustn't","needn't","no","nor","not","shan't","shouldn't","wasn't","weren't","wouldn't"}

  #print(len(not_stop))

  # set difference operation take place
  updated_stopwords = stopwords - not_stop
              
  #print(len(updated_stopwords))

  import re

  updated_reviews = []
  for review in reviews :
    
    # convert into lower case
    # this maintains uniformity in the document
    review = review.lower()
    
    # Replace every character except A-Z, a-z,space 
    # and punctuation (we'll need it for negation)
    # with empty string
    review = re.sub(r'[^A-Za-z .]','',review)
    
    # we need full stop symbol , for
    # breking review into statement wise
    review = review.replace(".", " .")
    
    # reduce words to their root word
    #ps = PorterStemmer() 
      
    # review string breaks into tokens(words)i.e. list of words
    tokens = word_tokenize(review)
     
    tokenized_review = []
    
      # iterate through each word from the list of words
    for token in tokens :
      
      #token = ps.stem(token)
      
      # remove stopwords and one char words
      if (len(token) > 1 or token == ".") and token not in stopwords :
        
        # add the token element to the end
        # of the tokenized_review list 
        tokenized_review.append(token)
    
    # again got a review string after cleaning
    review = " ".join(tokenized_review)
    
    updated_reviews.append(review)
   
  #print(updated_reviews[1:10])

  #updated_reviews = pd.Series(updated_reviews)
  #updated_data2 = updated_data2.iloc[:,:5]
  #updated_reviews

  updated_data2.loc[:,'updated_reviews'] = pd.Series(updated_reviews, index=updated_data2.index) #updates index
  #print(updated_data2[1:10])

  #updated_data2.loc[updated_data2['drugName'] == 'Guanfacine']

  # sample data is taken
  # updated_data2=updated_data2.loc[0:500,:]

  # checking the result
  # convert data_frame/series into array like structure
  arr = updated_data2.loc[ : ,['drugName','usefulCount']].values
  #arr[0][1]

  # this dictionary contains medicine name,reviews and its useful count
  medicines_reviews_with_usefulcount = dict.fromkeys(medicines_name,"")

  # iterating through each medicine
  for medicine in medicines_name :
    
    # dataframe consisting of same medicines data
    df1 = updated_data2.loc[updated_data2['drugName'] == medicine]
    
    # values attribute changes dataframe/series into array data structure
    specific_review_with_usefulcount_arr = df1.loc[ : ,['updated_reviews','usefulCount']].values
    
    specific_review_with_usefulcount_list = []
    
    for row in specific_review_with_usefulcount_arr :
      specific_review_with_usefulcount_list.append((row[0],row[1]))
      
    # store for each medicine
    medicines_reviews_with_usefulcount[medicine] = specific_review_with_usefulcount_list
   

  for key,values in medicines_reviews_with_usefulcount.items() :
    pass
    #print(key,values)

  """
  import nltk
  nltk.download('vader_lexicon')
  """

  from nltk.sentiment.vader import SentimentIntensityAnalyzer

  sid_ob = SentimentIntensityAnalyzer()

  # for checking the result
  #print(medicines_reviews_with_usefulcount)



  """to extract further information on sentiment count per medicine do analysis here.(for further reasearch work)
  ex.    medicine_Name         +ve    neutarl       -ve     (count per review per medicine)
              Abc                             2           1                0

  A dictionary is created below which contains medicine name, their overall rating, sentiment and overall useful count. 

  For calculation of overall rating :-
  Firstly the reviews are taken individually which are further broken down into statements. Then polarity is calculated and coverted into a scale of 0-5. Score is calculated by dividing the total polarity by no. of statements. This way sentiment of all the ratings as combined is calculated.

  For calculation of overall useful count :-
  Firstly the reviews are taken individually . Then polarity is calculated and coverted into a scale of 0-5. Score is calculated by dividing the total polarity by no. of statements in a single review. If the comment is +ve then the useful count is added, if -ve useful count is subtracted and if neutral then ignored.
  """

  # total no. of medicines with +ve, -ve, neutral reviews
  total_pos_count,total_neg_count,total_neu_count = 0, 0 , 0

  medicine_rating_sentiment_count_dict = dict.fromkeys(medicines_name)

  sentiment_list = ["positive","negative","neutral"]

  # values consist of list of reviews and useful count
  for medicine,values in medicines_reviews_with_usefulcount.items() :
    #pos_count,neg_count,neu_count = 0, 0 , 0
    #print(medicine)
    # tell the total no. of statements separated by '.' .
    
    # all values initialised/calculated per medicine
    total_no_statements = 0
    total_score = 0
    resultant_useful_count = 0
    
    
    for review in values :
      cmnt_list = review[0].split(".")
      
      each_review_score = 0
      total_no_statements += len(cmnt_list)
      
      for cmnt in cmnt_list :
        # polarity scores returns the seniment dictionary with scores
        sentiment_dict = sid_ob.polarity_scores(cmnt)
        
        each_review_score += sentiment_dict['compound']
        total_score += sentiment_dict['compound']
      
      # calulates overall each review score
      overall_per_reviewscore = (((each_review_score  / len(cmnt_list) ) * 5) + 5) / 2
      overall_per_reviewscore = round(overall_per_reviewscore,2)
       
      # for reseach work u can store overall_per_reviewscore vales in csv files
      
      # check sentiment for each review 
      if overall_per_reviewscore >= 2.75 :
        resultant_useful_count += review[1]
          
      elif overall_per_reviewscore <= 2.25 :
        resultant_useful_count -= review[1]
   
    # if medicine == 'Clinpro 5000' :
    #  print(total_score, len(reviews))
    #print(total_no_statements)
    overall_score = (((total_score / total_no_statements) * 5) + 5) / 2
    overall_score = round(overall_score,2)
    #print(round(overall_score,1))
    
    if overall_score >= 2.75 :
      
      #print(medicine, overall_score)
      total_pos_count += 1
      medicine_rating_sentiment_count_dict[medicine] = [overall_score,sentiment_list[0],resultant_useful_count]
      
    elif overall_score <= 2.25 :
      total_neg_count += 1
      medicine_rating_sentiment_count_dict[medicine] = [overall_score,sentiment_list[1],resultant_useful_count]
    
    else :
      total_neu_count += 1
      medicine_rating_sentiment_count_dict[medicine] = [overall_score,sentiment_list[2],resultant_useful_count]

    
  #print(total_pos_count,total_neg_count,total_neu_count)  
  i = 0
  for key,values in medicine_rating_sentiment_count_dict.items():
    #print(key,values)
    i += 1
    if i == 10 :
      break

  # sample view
  """for key in ['Oseltamivir', 'Tamiflu', 'Zanamivir', 'Relenza'] :
    print(medicine_rating_sentiment_dict[key])"""

  """extract useful count per medicines and store it in the above dictionary.

  > Indented block
  """

  # Dictionary is created which store overall details corresponding to the conditions.
  # this is dictionary of dictionary of list .
  # like condition->medicine1->[ratings, +ve, useful count]...etc.
  condition_details = {}

  # iterate through each condition
  for key,values in condition_with_medicines_dict.items() :
    
    # This dictionary contains ll medicine and its value list for particular condition
    local_dict = {}
    
    # iterate through each medicine name of particular medicine
    for value in values :
      if value in medicine_rating_sentiment_count_dict : 
        local_dict[value] = medicine_rating_sentiment_count_dict[value]
      
      # print(local_dict)  
    condition_details[key] = local_dict

  #print(condition_details)

  #print(condition_details['adhd'])

  #print(list(condition_details['adhd'].items()))

  #print(condition_details['adhd']['Guanfacine'][0])
  #list(condition_details['adhd'].values())[0][0]

  #print(list(condition_details['adhd'].keys()))

  #print(sorted(condition_details['adhd'].keys(),key = lambda element : condition_details['ADHD'][element][0] ))

  # get the value from the condition entry box and covert it into lower case
  input_condition = entry_condition.get().lower() #input("enter condition name: ")

  answer1 = sorted(condition_details[input_condition].items(),key = lambda element : element[1][0])
  # sorted(condition_details['adhd'].items(),key = lambda element : element[1][0] )

  # print(answer1[-1][0],answer1[-1][1][0],answer1[-1][1][1])

  # insert medicine name in the result_medicine entry box
  result_medicine.insert(15,str(answer1[-1][0]))

  # insert medicine rating in the result_medicine_rating entry box
  result_medicine_rating.insert(15,str(answer1[-1][1][0]))

  # insert medicine sentimen in the result_medicine_sentiment entry box
  result_medicine_sentiment.insert(15,str(answer1[-1][1][1]))
  
"""
# sample
import operator

dict = {1:'a',0:'c',2:'b'}
sorted(dict.items(),key = operator.itemgetter(1))
"""

if __name__ == "__main__" :
  
  from tkinter import *

  # create a gui root window
  window = Tk()

  # v = IntVar()

  # set the title of the gui window
  window.title("Samhit")

  # set the geometry of the gui window
  window.geometry("400x400")

  window.configure(background = "light green")
  
  #Radio button
  #Radiobutton(window, text='Condition', padx = 50, variable=v, value=1).grid(row=1, column=1) 
  #Radiobutton(window, text='Medicine Name', padx=50, variable=v, value=2).grid(row=2, column=1) 

  # Create a label 
  label1 = Label(window, text = "Condition Name : ", fg = 'black', bg = 'red')
  label2 = Label(window, text = "Medicine Name : ", fg = 'black', bg = 'red')
  label3 = Label(window, text = "Medicine Rating : ", fg = 'black', bg = 'red')
  label4 = Label(window, text = "Sentiment : ", fg = 'black', bg = 'red')

  # set label at specified coordinates.
  label1.grid(row = 1, column = 1,sticky ="E")
  label2.grid(row = 3, column = 1,sticky ="E")
  label3.grid(row = 4, column = 1,sticky ="E")
  label4.grid(row = 5, column = 1,sticky ="E")

  # create a entry boxes and place at specified coordinates.
  entry_condition = Entry(window)
  entry_condition.grid(row=1, column=2, ipadx ="50")

  # create a button and place at specified position
  button = Button(window, text='Search', command = tell_medicine)
  button.grid(row=2, column=2)
  
  #entry_medicine = Entry(window)
  #entry_medicine.grid(row=2, column=3)

  result_medicine = Entry(window)
  result_medicine.grid(row=3, column=2,ipadx ="50")

  result_medicine_rating = Entry(window)
  result_medicine_rating.grid(row=4, column=2,ipadx ="50")
  
  result_medicine_sentiment = Entry(window)
  result_medicine_sentiment.grid(row=5, column=2,ipadx ="50") 
  

  # start the GUI
  window.mainloop()

